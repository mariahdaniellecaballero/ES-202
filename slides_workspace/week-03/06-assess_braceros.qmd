---
title: "[Assess] Bracero Farmworker Case Study"
subtitle: "üìç Yakima Valley, WA"
date: "September 19, 2025"
format: 
  revealjs:
    theme:
      - default
    css: custom.scss
    transition: fade
    slide-number: true
    incremental: false 
    chalkboard: true
    center: true
execute:
  freeze: auto
---

# Class Overview 
- Centering activity
- Setting the stage
- Paired coding
- Group Debrief

## Centering Activity
* Reena :-)

## Exit Ticket Results {.smaller}
```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: true

library(tidyverse)
library(showtext)
library(wesanderson)

column1_data <- c("Snack Suggestions", "Animal Drawing", "More/varied Readings", "More discussion/Active Learning", "More Detailed R Instructions", "Readings as pdfs")
column2_data <- c(6, 6, 4, 6, 3, 1)

# Create a two-column dataframe
df <- data.frame(
  Topic = column1_data,
  Count = column2_data
)

my_palette <- wes_palette("FantasticFox1", 6, type = "continuous")

# plot
df %>% 
  mutate(Topic = factor(Topic, levels = c("Readings as pdfs","More Detailed R Instructions", "More/varied Readings", "More discussion/Active Learning", "Animal Drawing",  "Snack Suggestions"))) %>% 
  ggplot(aes(x = Topic, y = Count, fill = Topic)) + 
  geom_bar(stat = "identity") + 
  coord_flip() + 
  scale_fill_manual(values = my_palette) + 
  theme_minimal() + 
  theme(legend.position = "none") + 
  theme(text = element_text(family = "Raleway"))
```

# Setting the Stage
- This week's focus is on data tidying and transformation
- Using metadata from 90 interviews in the Bracero Archive that I scraped
- Important to note that each row represents a person, a life, and a family impacted by the Bracero Program

## Learning Outcomes
- Understand data structure
- Transform and tidy data for necessary questions
- Explore and summarize patterns
- Connect your findings to theoretical understandings of procedural justice

## Let's get Started
- Find your pair
- Open Posit

## First Steps
- Import Data
- Load packages
  - You may need to install readxl using `install.packages("package name")`.
```{r}
#| warning: false
#| message: false
#| echo: true

library(readxl) # for loading data
library(tidyverse) # for tidying
```

```{r}
# | eval: true
# | echo: false
bracero <- read_excel("~/Google Drive/My Drive/Teaching/ES-202/Case Study Code/data/week_03/bracero_pull.xlsx")
```

## Load Data
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: false
bracero <- read_excel("data/bracero_pull.xlsx")
```


## Our data {.smaller}
- 90 rows (interviews)
- 6 variables (all `chr` type)
  - title = Person interviewed
  - subject = topic of interview
  - description = summary of interview
  - date = date of interview
  - identifier = link to original interview file
  - language = language interview was conducted in
```{r}
#| warning: false
#| message: false
#| echo: true
glimpse(bracero)
```

## Variable Types {.smaller}
We will work primarily with five types of variables in this course:

- `chr` is character
- `dbl` is double (number)
- `int` is an integer
- `date` is date
- `fct` is factor

<span style="color:red;">Thoughts on what variables we may want to change the data types of?</span>

```{r}
#| warning: false
#| message: false
#| echo: false

glimpse(bracero)
```

# Transforming Data (Columns) {.smaller}
- Four functions can change the *columns* of your data without affecting your *rows* 
  - mutate(): creates new columns based on existing ones
  - select(): chooses what columns you want in your dataframe
  - rename(): changes the names of current columns
  - relocate(): changes the position of those columns 

## mutate() function {.smaller}
- mutate() creates new columns based on existing ones
- We use the `mutate()` function to create a new column `year`, using the `year()` function to change the original `date` column to include only the year, formatted as a date.
```{r}
#| warning: false
#| message: false
#| echo: true

bracero <- bracero |>
  mutate(year = year(date)) 
```

## mutate() function (cont.) {.smaller}
- We can also pair it with additional functions, such as ifelse statements. 
  - `%in%c()` allows you to list multiple matches in the `subject` column.

![](images/ifelse.png)
```{r}
bracero |> 
 mutate(subject_binary = ifelse(subject %in%c("bracero", "Bracero"), "Bracero", "Non-bracero"))
```

## select() function {.smaller}
- `select()` can be used to select or deselect columns. 
- Perhaps we'd like to remove the original `date` column from our dataframe. 
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: false
#| code-line-numbers: "|3|7|11"

# select column you don't want
bracero |>
 select(-date)

# select columns you do want
bracero |>
 select(title, subject, description, date, identifier, language, year)

# select columns in a row, except the column you don't want
bracero |>
  select(title:description, identifier:year)
```

## rename() function {.smaller}
- `rename()` changes the names of current columns
  - let's rename `title` to something more descriptive like `interviewee`.
```{r}
#| warning: false
#| message: false
#| echo: true

bracero |>
  rename("interviewee" = "title")
```

## relocate() function {.smaller}
- `relocate()` changes the position of  columns 
- `relocate()` automatically puts the column at the front, so you have to specify the column's location, and `.after` or `.before`.

```{r}
#| warning: false
#| message: false
#| echo: true

bracero |> 
 relocate(identifier, .after = language)
```

## Put it together {.smaller}
- We can put all of these data transformation actions together using the `|>` function
  - line 1: creates new dataframe called `bracero_clean`
  - line 2: creates formatted year column called `year` from the original `date` column.
  - line 3: selects for all columns *except* for the old `date` column
  - line 4: renames the `title` column to `interviewee`
  - line 5: moves the `indentifier` column to after the `year` column.
```{r}
#| warning: false
#| message: false
#| echo: true
#| code-line-numbers: "1|2|3|4|5"

bracero_clean <- bracero |>
  mutate(year = year(date)) |> 
  select(-date) |> 
  rename("interviewee" = "title") |> 
  relocate(identifier, .after = year)
```

# Exercise One {.smaller}
- Starting with the `bracero` dataframe, code the following three actions using into a new dataframe called `bracero_ex1`
  - mutate the `date` column into a new column, called `year` using the `year()` function.
  - select the `title`, `year`, and `description` columns.
  - relocate the `year` column to be the first in the dataframe.

# Transforming Data (Rows)
- Moving on to rows! 
  - `filter()` is a function that allows you to keep rows of interest (but won't change the order of your rows) 
  - `arrange()` changes the order of your rows (but won't filter for anything)

## filter() function {.smaller}
- Use the `filter()` function to select rows that correspond to values of interest. 
- use `==` to filter the `language` column for rows with a direct match (in this case `spa`)
```{r}
#| warning: false
#| message: false
#| echo: true
bracero_clean |>
  filter(language == "spa")
```

## filter() operations {.smaller}
  - `>`  greater than 
  - `>=`  greater than or equal to
  - `<` less than
  - `<=` less than or equal to
  - `==` equal to
  - `!=` does not equal

  - Can use `&` to combine conditions (and)
  - `|` to select multiple conditions (or)
- Perhaps we're interested in interviews that took place after 2004 AND are in English:
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: false

bracero_clean |>
  filter(year >= 2004 & language == "eng")
```

## filter() and str_detect() {.smaller}
- We can also combine filter with the `str_detect()` function, to look for character matches in a column (in this case the `interviewee` column, with any matches including `Alberto` .
```{r}
#| warning: false
#| message: false
#| echo: true
bracero_clean |> 
  filter(str_detect(interviewee, "Alberto"))
```

## arrange()
- `arrange()` sorts your rows based on the values in the columns. 
- If you sort more than one row, it will sort the first variable, and the others will be used to "break ties"
- including `desc()` will sort your column values big to small. 
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: false

bracero_clean |> 
  arrange(desc(year, interviewee))
```

## Exercise Two {.smaller}
1. Filter the `bracero_ex_1` dataframe for any interviews that took place before 2005 (using the `year` column) with an interviewee whose name includes ‚ÄúGuadalupe‚Äù.

2. Arrange the `bracero_ex1` data frame in descending order by `year`. What was the year, how many interviews took place in that year, and who is listed first?

3. Filter the `bracero_clean` dataframe for any description columns that mention "California". How many interviewees are there?


# Grouping Data 

## group_by() function {.smaller}
- `group_by()` function is really helpful for sorting your data into groups for analysis. 
- `group_by()` function does not change your data, but *will change* subsequent operations if you use them in tandem with a `group_by()`
- You can also group by multiple columns. In this case, I've grouped by both `year` and `language`
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true

 bracero_clean |>
  group_by(year, language)
```


## summarize()
- `summarize()` is often used in tandem with the `group_by()` function to calculate summary statistic(s) for a group. 
- In this case we are grouping the `bracero_clean` dataframe by the values in the `language` column, and summarizing the number of interviews using the `n()` function in a new column called `n_interviews`.
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
bracero_clean |>
 group_by(language) |>
 summarize(n_interviews = n())
```

## Other summarize functions
- You can summarize values across groups using other functions, such as: 
  - median() = median
  - mean() = average
  - sum() = sum
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
bracero_clean |>
 group_by(language) |>
 summarize(avg_date = mean(year))
```

## slice {.smaller}
- `slice_` functions help select a subset of rows
 - slice_head(n = 5) will take the first five rows of the data
 - slice_tail(n = 5) will take the last five rows of the data
 - slice_min(x, n = 5) will take the five rows of data with the lowest values for column x. 
 - slice_max(x, n = 5) will take the five rows of data with the highest values for column x. 
 - slice_sample(n = 5) will select 5 random rows of data.
```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
bracero_clean |>
  slice_min(year, n = 3)
```

# Exercises Three and Four {.smaller}
- See assignment! 
  - Part 3: grouping data 
  - Part 4: Listen to an interview from the [Bracero archive](https://braceroarchive.org/), and answer questions related your interview/course readings.

## Logistics 
- Tuesday: two readings on rural electrification in NC, one oral history
  - Kat leading centering activity :-)
- Grading HW 01 and 02 will be done this weekend!

