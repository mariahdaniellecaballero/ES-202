{
  "hash": "600bf6d4d0ee29eb4c5c2620b2808bf9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"[Assess] Solar Energy Case Study\"\nsubtitle: \"üìç Navajo Nation, U.S.\"\ndate: \"October 24, 2025\"\nformat: \n  revealjs:\n    theme:\n      - default\n    css: custom.scss\n    transition: fade\n    slide-number: true\n    incremental: false \n    chalkboard: true\n    center: true\nexecute:\n  freeze: auto\n---\n\n## Class Overview \n- Centering activity\n- Setting the stage\n- Paired coding\n\n## Centering Activity\n- Simmie :-)\n- [Link](https://youtu.be/tUtPiYbnUfA?si=rOgnVpzmUzWpCtzv) (see 1:32)\n\n## Mid-Semester Update\n- Got 13 responses! \n- Realized I can't make this for credit AND make it anonymous\n- If you're one of the two people who haven't filled out the feedback form, let's talk!\n\n## Setting the Stage\n- This week's focus is on making maps!\n- Using publicly available data from the National Renewable Energy Laboratory (NREL), the U.S. Census, and the Department of Energy (DOE). \n\n## A Note on Tribal Data {.smaller}\n- Really quite hard to find data for Tribal Census Tracts. \n  - Had to use Areal Weight Interpolation to generate estimates from census tract values. \n  - This approach is especially imperfect when the population is not distributed equally. \n![](images/tribal_cts.png)\n\n\n## Learning Outcomes\n1. Read spatial data and transform its projection \n2. Create a Chloropleth Map\n3. Creating a Bivariate Map\n4. Connect findings to theoretical understandings of the five tenets of Environmental Justice\n\n## Let's get Started\n- Find your pair\n- Open Posit\n\n## Loading packages {.smaller}\n- Install 4 new packages. \n  - Run lines 1-4 **in your console (below)**\n- Load 6 packages\n  - Type lines 6-11 **in your analysis.qmd (above)**\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"crsuggest\")\n# install.packages(\"biscale\")\n# install.packages(\"RColorBrewer)\n# install.packages(\"cowplot)\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(crsuggest)\nlibrary(biscale)\nlibrary(RColorBrewer)\nlibrary(cowplot)\n```\n:::\n\n\n## Reading in data {.smaller}\n- Use the `read_sf()` package for reading a shapefile.\n  - shapefiles have multiple parts, so they're stored in their own folder (nn_sf), and the shapefile is called `nn_sf.shp`. \n  - We have to type the full filepath to read in the data!\n\n::: {.cell}\n\n```{.r .cell-code}\nnn_sf <- read_sf(\"data/nn_sf/nn_sf.shp\")\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n## Take a Look at the Data {.smaller}\n- Last time we used `mapview()` to take a quick look at our spatial data. \n  - We can actually use ggplot() with a new geom!\n    - ‚ú®geom_sf()‚ú®\n\n::: {.cell}\n\n```{.r .cell-code}\nnn_sf |>\n  ggplot() +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](16-assess_solar_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n\n## Project Data {.smaller}\n- ggplot() assumes planar data (x and y axes)\n  - But the earth is round.. \n- Projections allow us to visualize the Earth on a planar surface, while trying to preserve accuracy for analyses. \n  - This is expecially important for local maps (like ours)\n  - We can use the `suggest_crs()` function to suggest the best coordinate system for our data.\n  - `st_transform()` will change our projection if supplied a new `crs_code`. \n\n::: {.cell}\n\n```{.r .cell-code}\n# check projection\nnn_sf |> st_crs()\n\n# suggest better crs (may want to # this out in .qmd)\n#suggest_crs(nn_sf)\n\n# Change projection\nnn_sf <- nn_sf |>\n  st_transform(6627)\n```\n:::\n\n\n## EX_01 {.smaller}\nLoad and project locations of large-scale energy projects in the data folder: \n\n1. Use `read_sf` to read the `energy_pts.shp` shapefile into your environment, call it `energy_pts`.\n2. Change the projection of your `energy_pts` shapefile to match the Navajo Nation shapefile. \n3. Tell me about this data, what kinds of energy projects are included in the shapefile, and which produces the most electricity? \n\n## Making a Chloropleth Map {.smaller}\n\n## Simple Fill Map {.smaller}\n- We can use the same ggplot aesthetics (fill, color, size, etc) to visualize variables on a map. \n  - For instance, we can change the `fill` in our map to represent Average Energy Burden (`avg_eb`).\n  - Any thoughts on the legend, though?  \n\n::: {.cell}\n\n```{.r .cell-code}\nnn_sf |>\n  ggplot() +\n  geom_sf(aes(fill = avg_eb))\n```\n\n::: {.cell-output-display}\n![](16-assess_solar_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n## Create Chloropleth Categories {.smaller}\n- Chloropleths are helpful because they allow the viewer to quickly compare values across space. \n  - To create our chloropleth categories, we should first understand how our data is distributed.\n  - Then, we can use the `mutate()` function to create a new variable `avg_eb_cat` using the `cut()` function. \n    - Breaks start with our rounded lowest number, and end with the rounded highest number. \n\n::: {.cell}\n\n```{.r .cell-code}\n# look at data distribution\nsummary(nn_sf$avg_eb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  3.644   4.988   5.304   5.425   5.945   7.820       1 \n```\n\n\n:::\n\n```{.r .cell-code}\n# mutate variables using \"cut\"\nnn_sf <- nn_sf |>\n  mutate(avg_eb_cat = cut(avg_eb,\n    breaks = c(3, 4, 5, 6, 8),\n    labels = c(\"3‚Äì4%\", \"4‚Äì5%\", \"5‚Äì6%\", \"6‚Äì8%\")\n  ))\n```\n:::\n\n\n## Plot Chloropleth {.smaller}\n- Lastly, we can define a color palette (I suggest a sequential palette, to showcase the low to high values). \n  - I use the `RColorBrewer` package to define my pallete (read more [here](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html)!)\n- Then, we plot and change a few aesthetics!\n  - Change the fill to our new categorical variable, `avg_eb_cat`\n  - Change the linewidth\n  - Use `scale_fill_manual()` to use my palette, and rename the legend \n  - Use `theme_void()` to ensure a blank base plot. \n\n::: {.cell}\n\n```{.r .cell-code}\n# create a palette\nmy_palette <- brewer.pal(n = 4, name = \"Oranges\")\n\n\n# plot!\nnn_sf |>\n  ggplot() +\n  geom_sf(aes(fill = avg_eb_cat), linewidth = 0.05) +\n  scale_fill_manual(\n    values = my_palette,\n    name = \"Average Energy Burden\"\n  ) +\n  theme_void()\n```\n:::\n\n\n## Et voil√†!\n\n::: {.cell}\n::: {.cell-output-display}\n![](16-assess_solar_files/figure-revealjs/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n\n## Bonus: Layer Multiple Shapefiles {.smaller}\n- We can actually layer multiple shapefiles on top of one another. \n  - Take the previous code, and indicate the dataframe in the `geom_sf()` layer, rather than piped at the top. \n  - Add another `geom_sf()` for the `energy_pts` layer, change the `size` and `color` aesthetics. \n  - Change the color aesthetics using `scale_color_manual()`\n\n::: {.cell}\n\n```{.r .cell-code}\n# previous code\nggplot() +\n  geom_sf(data = nn_sf, aes(fill = avg_eb_cat), linewidth = 0.05) +\n  scale_fill_manual(\n    values = my_palette,\n    name = \"Average Energy Burden\"\n  ) +\n  # added points sf and changed size + color\n  geom_sf(\n    data = energy_pts, aes(size = totl_mw, color = type),\n    alpha = 0.8\n  ) +\n  scale_color_manual(\n    values = c(\"black\", \"yellow\", \"gray\"),\n    name = \"Plant Type\"\n  ) +\n  theme_void()\n```\n:::\n\n\n## The Results\n\n::: {.cell}\n::: {.cell-output-display}\n![](16-assess_solar_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n## EX_02 {.smaller}\nCreate a chloropleth map using a continuous variable of your choosing in the `nn_sf` shapefile. Note that you can refer to the `nn_sf_dictionary.xlsx` file in your data folder if you're unsure of a variable name. \n\n1. Look at the distribution of your variable to determine your bins using the `summary()` function.\n2. Create a new categorical variable using the `mutate()` and `cut()` functions\n3. Create a palette of your choosing, (make sure the colors make sense for a chloropleth!) \n4. Create your chloropleth map, and note any interesting spatial trends. \n\n\n## Create a Bivariate Map \n- bivariate mapping allows us to visualize two variables (e.g., the residential solar potential `npv_rs_` and percent of single family homes `perc_sf`) in the same map.\n\n## Create a Bivariate Dataframe {.smaller}\n- We'll use the `biscale` package to create a new dataframe called `bi_var` categories are assigned to the data using the `bi_class()` function.\n- `npv_rs_` is our x, perc_sf  is our y, and we'll choose fisher breaks for our style, and 3 colors for the dim option.\n  - **NOTE**: Legend breaks vary by the story we‚Äôre trying to tell. There‚Äôs a handy book chapter that details the differences in legend classifications [here](https://geographicdata.science/book/notebooks/05_choropleth.html#).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbi_var <- bi_class(nn_sf,\n  x = npv_rs_, y = perc_sf,\n  style = \"fisher\", dim = 3)\n\nbi_var$bi_class\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"2-2\" \"3-1\" \"3-2\" \"2-3\" \"3-3\" \"2-2\" \"2-2\" \"3-3\" \"3-1\" \"3-3\" \"3-1\" \"3-1\"\n[13] \"3-1\" \"3-3\" \"3-3\" \"2-2\" \"3-3\" \"3-3\" \"3-1\" \"3-2\" \"3-3\" \"3-2\" \"3-2\" \"3-1\"\n[25] \"3-1\" \"2-1\" \"2-1\" \"3-3\" \"2-3\" \"3-2\" \"2-1\" \"2-2\" \"3-3\" \"3-1\" \"3-3\" \"2-1\"\n[37] \"2-2\" \"1-2\"\n```\n\n\n:::\n:::\n\n\n## Create Bivariate Map {.smaller}\n- The `biscale` package uses the ggplot2 approach, which we‚Äôre already familiar with! \n - We create a `ggplot()` object, add a `geom_sf()` object, specifying our new `bi_var` dataframe, our fill column,  `bi_class`, and some other aesthetic details, such as line color and width.\n\nI chose the ‚ÄúBluegill‚Äù palette for this approach, but there are [several others](https://cran.r-project.org/web/packages/biscale/vignettes/bivariate_palettes.html) available.\n\n::: {.cell}\n\n```{.r .cell-code}\nbi_var_map <- ggplot() +\n  geom_sf(\n    data = bi_var, aes(fill = bi_class),\n    color = \"white\", size = 0.1, show.legend = FALSE\n  ) +\n  bi_scale_fill(pal = \"Bluegill\", dim = 3) +\n  bi_theme()\n```\n:::\n\n\n## Results {.smaller}\n\n::: {.cell}\n::: {.cell-output-display}\n![](16-assess_solar_files/figure-revealjs/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n\n## Create Bivariate Legend {.smaller}\n- I also want to create a nice legend to accompany this, so I‚Äôll use the `bi_legend()` function to specify my palette, the number of colors, and the labels I‚Äôd like.\n\n::: {.cell}\n\n```{.r .cell-code}\nbi_var_legend <- bi_legend(\n  pal = \"Bluegill\",\n  dim = 3,\n  xlab = \"Profitability for Residential PV\",\n  ylab = \"% SF Homes\",\n  size = 8\n)\nbi_var_legend\n```\n\n::: {.cell-output-display}\n![](16-assess_solar_files/figure-revealjs/unnamed-chunk-15-1.png){width=960}\n:::\n:::\n\n\n## Stitch it Together {.smaller}\n- The last step is adding the map and legend together, using the `ggdraw()` function from the `cowplot` package. \n  - `draw_plot()` adds your map and legend together in one plot. \n  - `x` (0 = left, 1 = right), and `y` (0 = bottom, 1 = top) changes the location of the legend\n  - `width` and `height` change the legend size relative to the map. \n\n::: {.cell}\n\n```{.r .cell-code}\nggdraw() +\n  draw_plot(bi_var_map) + \n  draw_plot(bi_var_legend,\n    x = 0.05,\n    y = 0.05,\n    width = 0.25, \n    height = 0.25)\n```\n:::\n\n\n## All Together Now! {.smaller}\n\n::: {.cell}\n::: {.cell-output-display}\n![](16-assess_solar_files/figure-revealjs/unnamed-chunk-17-1.png){width=960}\n:::\n:::\n\n\n## EX_03 {.smaller}\nCreate a bivariate map using a continuous variable of your choosing in the `nn_sf` shapefile. Note that you can refer to the `nn_sf_dictionary.xlsx` file in your data folder if you're unsure of a variable name. \n\n1. Create a new dataframe called `bivar_2` and use the `bi_class()` function to generate a bivariate dataframe for your two variables of interest. \n2. Create the bivariate map.\n3. Create an accompanying bivariate legend. \n4. Stitch the map and legend together to create your final map \n\n## EX_04 \nSee Posit assignment!\n\n## Logistics {.smaller}\n- Project proposal due tonight at 11:59 PM. \n- No class on Tuesday!\n- Native American and Indigenous Heritage Month starts November 1. \n  - November 3: ‚ÄúIndigenous Wisdom and the Teachings of Trees‚Äù \n  - November 5: Decolonizing Drag with Lady Shug\n  - November 9: Language Circle: Language, Identity and Community, An Indigenous Perspective\n  - November 13: The Colonial History of the American Legal System\n  - November 15: Davis Museum Tour: Colonial Legacies of Curatorial\nPractices",
    "supporting": [
      "16-assess_solar_files/figure-revealjs"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}